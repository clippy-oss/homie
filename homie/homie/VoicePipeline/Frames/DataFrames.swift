//
//  DataFrames.swift
//  homie
//
//  Voice Processing Pipeline - Data Frames
//  Normal-priority frames carrying audio, text, and image content
//

import Foundation

// MARK: - Audio Frame Protocol

/// Base protocol for frames carrying audio data
public protocol AudioFrame: DataFrame {
    /// Raw audio data (typically PCM format)
    var audioData: Data { get }

    /// Sample rate in Hz (e.g., 16000, 44100, 48000)
    var sampleRate: Int { get }

    /// Number of audio channels (1 = mono, 2 = stereo)
    var channels: Int { get }
}

// MARK: - InputAudioFrame

/// Audio captured from microphone or transport input
/// Flows downstream through the pipeline for processing (STT, VAD, etc.)
public struct InputAudioFrame: AudioFrame {
    public let id: UUID
    public let timestamp: Date
    public let name: String = "InputAudioFrame"

    public let audioData: Data
    public let sampleRate: Int
    public let channels: Int

    public init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        audioData: Data,
        sampleRate: Int = 16000,
        channels: Int = 1
    ) {
        self.id = id
        self.timestamp = timestamp
        self.audioData = audioData
        self.sampleRate = sampleRate
        self.channels = channels
    }
}

// MARK: - OutputAudioFrame

/// Audio to be played through speaker or sent via transport
/// Typically generated by TTS processors
public struct OutputAudioFrame: AudioFrame {
    public let id: UUID
    public let timestamp: Date
    public let name: String = "OutputAudioFrame"

    public let audioData: Data
    public let sampleRate: Int
    public let channels: Int

    public init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        audioData: Data,
        sampleRate: Int = 24000,
        channels: Int = 1
    ) {
        self.id = id
        self.timestamp = timestamp
        self.audioData = audioData
        self.sampleRate = sampleRate
        self.channels = channels
    }
}

// MARK: - Text Frame Protocol

/// Base protocol for frames carrying text data
public protocol TextFrame: DataFrame {
    /// The text content
    var text: String { get }
}

// MARK: - TranscriptionFrame

/// Final transcription result from speech-to-text processing
/// Contains the complete, finalized text from user speech
public struct TranscriptionFrame: TextFrame {
    public let id: UUID
    public let timestamp: Date
    public let name: String = "TranscriptionFrame"

    public let text: String

    /// Detected language code (e.g., "en", "es", "fr")
    public let language: String?

    /// Confidence score from 0.0 to 1.0
    public let confidence: Float?

    public init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        text: String,
        language: String? = nil,
        confidence: Float? = nil
    ) {
        self.id = id
        self.timestamp = timestamp
        self.text = text
        self.language = language
        self.confidence = confidence
    }
}

// MARK: - InterimTranscriptionFrame

/// Partial transcription result from speech-to-text processing
/// Represents text that is still being processed and may change
/// Useful for real-time feedback to users
public struct InterimTranscriptionFrame: TextFrame {
    public let id: UUID
    public let timestamp: Date
    public let name: String = "InterimTranscriptionFrame"

    public let text: String

    public init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        text: String
    ) {
        self.id = id
        self.timestamp = timestamp
        self.text = text
    }
}

// MARK: - LLMResponseFrame

/// Streaming response chunk from LLM processing
/// Multiple frames are sent as the LLM generates its response
public struct LLMResponseFrame: TextFrame {
    public let id: UUID
    public let timestamp: Date
    public let name: String = "LLMResponseFrame"

    public let text: String

    /// Whether this is the final chunk of the response
    public let isComplete: Bool

    public init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        text: String,
        isComplete: Bool = false
    ) {
        self.id = id
        self.timestamp = timestamp
        self.text = text
        self.isComplete = isComplete
    }
}

// MARK: - ImageFrame

/// Frame carrying image data for vision processing
/// Reserved for future multimodal support
public struct ImageFrame: DataFrame {
    public let id: UUID
    public let timestamp: Date
    public let name: String = "ImageFrame"

    /// Raw image data (typically PNG or JPEG encoded)
    public let imageData: Data

    /// Image width in pixels
    public let width: Int

    /// Image height in pixels
    public let height: Int

    public init(
        id: UUID = UUID(),
        timestamp: Date = Date(),
        imageData: Data,
        width: Int,
        height: Int
    ) {
        self.id = id
        self.timestamp = timestamp
        self.imageData = imageData
        self.width = width
        self.height = height
    }
}
