// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: whatsapp.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ChatType represents the type of a chat.
public enum Whatsapp_V1_ChatType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case `private` // = 1
  case group // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .private
    case 2: self = .group
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .private: return 1
    case .group: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Whatsapp_V1_ChatType] = [
    .unspecified,
    .private,
    .group,
  ]

}

/// MessageType represents the type of a message.
public enum Whatsapp_V1_MessageType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case text // = 1
  case image // = 2
  case video // = 3
  case audio // = 4
  case document // = 5
  case sticker // = 6
  case reaction // = 7
  case location // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .text
    case 2: self = .image
    case 3: self = .video
    case 4: self = .audio
    case 5: self = .document
    case 6: self = .sticker
    case 7: self = .reaction
    case 8: self = .location
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .text: return 1
    case .image: return 2
    case .video: return 3
    case .audio: return 4
    case .document: return 5
    case .sticker: return 6
    case .reaction: return 7
    case .location: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Whatsapp_V1_MessageType] = [
    .unspecified,
    .text,
    .image,
    .video,
    .audio,
    .document,
    .sticker,
    .reaction,
    .location,
  ]

}

/// EventType represents the type of a WhatsApp event.
public enum Whatsapp_V1_EventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case messageReceived // = 1
  case messageSent // = 2
  case messageRead // = 3
  case chatUpdated // = 4
  case connectionStatus // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .messageReceived
    case 2: self = .messageSent
    case 3: self = .messageRead
    case 4: self = .chatUpdated
    case 5: self = .connectionStatus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .messageReceived: return 1
    case .messageSent: return 2
    case .messageRead: return 3
    case .chatUpdated: return 4
    case .connectionStatus: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Whatsapp_V1_EventType] = [
    .unspecified,
    .messageReceived,
    .messageSent,
    .messageRead,
    .chatUpdated,
    .connectionStatus,
  ]

}

/// ConnectionStatus represents the connection state.
public enum Whatsapp_V1_ConnectionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case disconnected // = 1
  case connecting // = 2
  case connected // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .disconnected
    case 2: self = .connecting
    case 3: self = .connected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .disconnected: return 1
    case .connecting: return 2
    case .connected: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Whatsapp_V1_ConnectionStatus] = [
    .unspecified,
    .disconnected,
    .connecting,
    .connected,
  ]

}

/// JID represents a WhatsApp JID (Jabber ID).
public struct Whatsapp_V1_JID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: String = String()

  public var server: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Chat represents a WhatsApp chat.
public struct Whatsapp_V1_Chat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jid: Whatsapp_V1_JID {
    get {return _jid ?? Whatsapp_V1_JID()}
    set {_jid = newValue}
  }
  /// Returns true if `jid` has been explicitly set.
  public var hasJid: Bool {return self._jid != nil}
  /// Clears the value of `jid`. Subsequent reads from it will return its default value.
  public mutating func clearJid() {self._jid = nil}

  public var name: String = String()

  public var type: Whatsapp_V1_ChatType = .unspecified

  public var lastMessageTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastMessageTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastMessageTime = newValue}
  }
  /// Returns true if `lastMessageTime` has been explicitly set.
  public var hasLastMessageTime: Bool {return self._lastMessageTime != nil}
  /// Clears the value of `lastMessageTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastMessageTime() {self._lastMessageTime = nil}

  public var lastMessageText: String = String()

  public var unreadCount: Int32 = 0

  public var isMuted: Bool = false

  public var isArchived: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jid: Whatsapp_V1_JID? = nil
  fileprivate var _lastMessageTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Message represents a WhatsApp message.
public struct Whatsapp_V1_Message: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var chatJid: Whatsapp_V1_JID {
    get {return _storage._chatJid ?? Whatsapp_V1_JID()}
    set {_uniqueStorage()._chatJid = newValue}
  }
  /// Returns true if `chatJid` has been explicitly set.
  public var hasChatJid: Bool {return _storage._chatJid != nil}
  /// Clears the value of `chatJid`. Subsequent reads from it will return its default value.
  public mutating func clearChatJid() {_uniqueStorage()._chatJid = nil}

  public var senderJid: Whatsapp_V1_JID {
    get {return _storage._senderJid ?? Whatsapp_V1_JID()}
    set {_uniqueStorage()._senderJid = newValue}
  }
  /// Returns true if `senderJid` has been explicitly set.
  public var hasSenderJid: Bool {return _storage._senderJid != nil}
  /// Clears the value of `senderJid`. Subsequent reads from it will return its default value.
  public mutating func clearSenderJid() {_uniqueStorage()._senderJid = nil}

  public var type: Whatsapp_V1_MessageType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var isFromMe: Bool {
    get {return _storage._isFromMe}
    set {_uniqueStorage()._isFromMe = newValue}
  }

  public var isRead: Bool {
    get {return _storage._isRead}
    set {_uniqueStorage()._isRead = newValue}
  }

  /// Media fields
  public var mediaURL: String {
    get {return _storage._mediaURL}
    set {_uniqueStorage()._mediaURL = newValue}
  }

  public var mediaMimeType: String {
    get {return _storage._mediaMimeType}
    set {_uniqueStorage()._mediaMimeType = newValue}
  }

  public var mediaFilename: String {
    get {return _storage._mediaFilename}
    set {_uniqueStorage()._mediaFilename = newValue}
  }

  public var mediaSize: UInt64 {
    get {return _storage._mediaSize}
    set {_uniqueStorage()._mediaSize = newValue}
  }

  public var mediaThumbnail: Data {
    get {return _storage._mediaThumbnail}
    set {_uniqueStorage()._mediaThumbnail = newValue}
  }

  /// Reference fields
  public var quotedMessageID: String {
    get {return _storage._quotedMessageID}
    set {_uniqueStorage()._quotedMessageID = newValue}
  }

  public var reaction: Whatsapp_V1_Reaction {
    get {return _storage._reaction ?? Whatsapp_V1_Reaction()}
    set {_uniqueStorage()._reaction = newValue}
  }
  /// Returns true if `reaction` has been explicitly set.
  public var hasReaction: Bool {return _storage._reaction != nil}
  /// Clears the value of `reaction`. Subsequent reads from it will return its default value.
  public mutating func clearReaction() {_uniqueStorage()._reaction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Reaction represents a reaction to a message.
public struct Whatsapp_V1_Reaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetMessageID: String = String()

  public var emoji: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_DisconnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_DisconnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_LogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_LogoutResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_GetConnectionStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_GetConnectionStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Whatsapp_V1_ConnectionStatus = .unspecified

  public var isLoggedIn: Bool = false

  public var userJid: Whatsapp_V1_JID {
    get {return _userJid ?? Whatsapp_V1_JID()}
    set {_userJid = newValue}
  }
  /// Returns true if `userJid` has been explicitly set.
  public var hasUserJid: Bool {return self._userJid != nil}
  /// Clears the value of `userJid`. Subsequent reads from it will return its default value.
  public mutating func clearUserJid() {self._userJid = nil}

  public var pushName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userJid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_GetPairingQRRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_PairingQREvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Whatsapp_V1_PairingQREvent.OneOf_Payload? = nil

  public var qrCode: String {
    get {
      if case .qrCode(let v)? = payload {return v}
      return String()
    }
    set {payload = .qrCode(newValue)}
  }

  public var timeout: Bool {
    get {
      if case .timeout(let v)? = payload {return v}
      return false
    }
    set {payload = .timeout(newValue)}
  }

  public var success: Whatsapp_V1_PairingSuccess {
    get {
      if case .success(let v)? = payload {return v}
      return Whatsapp_V1_PairingSuccess()
    }
    set {payload = .success(newValue)}
  }

  public var error: String {
    get {
      if case .error(let v)? = payload {return v}
      return String()
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case qrCode(String)
    case timeout(Bool)
    case success(Whatsapp_V1_PairingSuccess)
    case error(String)

  }

  public init() {}
}

public struct Whatsapp_V1_PairingSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userJid: Whatsapp_V1_JID {
    get {return _userJid ?? Whatsapp_V1_JID()}
    set {_userJid = newValue}
  }
  /// Returns true if `userJid` has been explicitly set.
  public var hasUserJid: Bool {return self._userJid != nil}
  /// Clears the value of `userJid`. Subsequent reads from it will return its default value.
  public mutating func clearUserJid() {self._userJid = nil}

  public var pushName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userJid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_PairWithCodeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phoneNumber: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_PairWithCodeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pairingCode: String = String()

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_GetChatsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limit: Int32 = 0

  public var offset: Int32 = 0

  public var includeArchived: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_GetChatsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chats: [Whatsapp_V1_Chat] = []

  public var totalCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_GetChatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jid: Whatsapp_V1_JID {
    get {return _jid ?? Whatsapp_V1_JID()}
    set {_jid = newValue}
  }
  /// Returns true if `jid` has been explicitly set.
  public var hasJid: Bool {return self._jid != nil}
  /// Clears the value of `jid`. Subsequent reads from it will return its default value.
  public mutating func clearJid() {self._jid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_GetChatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chat: Whatsapp_V1_Chat {
    get {return _chat ?? Whatsapp_V1_Chat()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chat: Whatsapp_V1_Chat? = nil
}

public struct Whatsapp_V1_GetMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatJid: Whatsapp_V1_JID {
    get {return _chatJid ?? Whatsapp_V1_JID()}
    set {_chatJid = newValue}
  }
  /// Returns true if `chatJid` has been explicitly set.
  public var hasChatJid: Bool {return self._chatJid != nil}
  /// Clears the value of `chatJid`. Subsequent reads from it will return its default value.
  public mutating func clearChatJid() {self._chatJid = nil}

  public var limit: Int32 = 0

  public var beforeMessageID: String = String()

  public var afterMessageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatJid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_GetMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Whatsapp_V1_Message] = []

  public var hasMore_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_SendMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatJid: Whatsapp_V1_JID {
    get {return _chatJid ?? Whatsapp_V1_JID()}
    set {_chatJid = newValue}
  }
  /// Returns true if `chatJid` has been explicitly set.
  public var hasChatJid: Bool {return self._chatJid != nil}
  /// Clears the value of `chatJid`. Subsequent reads from it will return its default value.
  public mutating func clearChatJid() {self._chatJid = nil}

  public var text: String = String()

  public var quotedMessageID: String = String()

  /// For media messages
  public var mediaData: Data = Data()

  public var mediaMimeType: String = String()

  public var mediaFilename: String = String()

  public var type: Whatsapp_V1_MessageType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatJid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_SendMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Whatsapp_V1_Message {
    get {return _message ?? Whatsapp_V1_Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Whatsapp_V1_Message? = nil
}

public struct Whatsapp_V1_SendReactionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatJid: Whatsapp_V1_JID {
    get {return _chatJid ?? Whatsapp_V1_JID()}
    set {_chatJid = newValue}
  }
  /// Returns true if `chatJid` has been explicitly set.
  public var hasChatJid: Bool {return self._chatJid != nil}
  /// Clears the value of `chatJid`. Subsequent reads from it will return its default value.
  public mutating func clearChatJid() {self._chatJid = nil}

  public var messageID: String = String()

  public var emoji: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatJid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_SendReactionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_MarkAsReadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatJid: Whatsapp_V1_JID {
    get {return _chatJid ?? Whatsapp_V1_JID()}
    set {_chatJid = newValue}
  }
  /// Returns true if `chatJid` has been explicitly set.
  public var hasChatJid: Bool {return self._chatJid != nil}
  /// Clears the value of `chatJid`. Subsequent reads from it will return its default value.
  public mutating func clearChatJid() {self._chatJid = nil}

  public var messageIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatJid: Whatsapp_V1_JID? = nil
}

public struct Whatsapp_V1_MarkAsReadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_StreamEventsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventTypes: [Whatsapp_V1_EventType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Whatsapp_V1_WhatsAppEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Whatsapp_V1_EventType = .unspecified

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var payload: Whatsapp_V1_WhatsAppEvent.OneOf_Payload? = nil

  public var messageEvent: Whatsapp_V1_MessageEvent {
    get {
      if case .messageEvent(let v)? = payload {return v}
      return Whatsapp_V1_MessageEvent()
    }
    set {payload = .messageEvent(newValue)}
  }

  public var chatEvent: Whatsapp_V1_ChatEvent {
    get {
      if case .chatEvent(let v)? = payload {return v}
      return Whatsapp_V1_ChatEvent()
    }
    set {payload = .chatEvent(newValue)}
  }

  public var connectionEvent: Whatsapp_V1_ConnectionEvent {
    get {
      if case .connectionEvent(let v)? = payload {return v}
      return Whatsapp_V1_ConnectionEvent()
    }
    set {payload = .connectionEvent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case messageEvent(Whatsapp_V1_MessageEvent)
    case chatEvent(Whatsapp_V1_ChatEvent)
    case connectionEvent(Whatsapp_V1_ConnectionEvent)

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Whatsapp_V1_MessageEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Whatsapp_V1_Message {
    get {return _message ?? Whatsapp_V1_Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Whatsapp_V1_Message? = nil
}

public struct Whatsapp_V1_ChatEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chat: Whatsapp_V1_Chat {
    get {return _chat ?? Whatsapp_V1_Chat()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chat: Whatsapp_V1_Chat? = nil
}

public struct Whatsapp_V1_ConnectionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Whatsapp_V1_ConnectionStatus = .unspecified

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "whatsapp.v1"

extension Whatsapp_V1_ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CHAT_TYPE_UNSPECIFIED\0\u{1}CHAT_TYPE_PRIVATE\0\u{1}CHAT_TYPE_GROUP\0")
}

extension Whatsapp_V1_MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MESSAGE_TYPE_UNSPECIFIED\0\u{1}MESSAGE_TYPE_TEXT\0\u{1}MESSAGE_TYPE_IMAGE\0\u{1}MESSAGE_TYPE_VIDEO\0\u{1}MESSAGE_TYPE_AUDIO\0\u{1}MESSAGE_TYPE_DOCUMENT\0\u{1}MESSAGE_TYPE_STICKER\0\u{1}MESSAGE_TYPE_REACTION\0\u{1}MESSAGE_TYPE_LOCATION\0")
}

extension Whatsapp_V1_EventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0EVENT_TYPE_UNSPECIFIED\0\u{1}EVENT_TYPE_MESSAGE_RECEIVED\0\u{1}EVENT_TYPE_MESSAGE_SENT\0\u{1}EVENT_TYPE_MESSAGE_READ\0\u{1}EVENT_TYPE_CHAT_UPDATED\0\u{1}EVENT_TYPE_CONNECTION_STATUS\0")
}

extension Whatsapp_V1_ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONNECTION_STATUS_UNSPECIFIED\0\u{1}CONNECTION_STATUS_DISCONNECTED\0\u{1}CONNECTION_STATUS_CONNECTING\0\u{1}CONNECTION_STATUS_CONNECTED\0")
}

extension Whatsapp_V1_JID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JID"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}user\0\u{1}server\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.server) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.server.isEmpty {
      try visitor.visitSingularStringField(value: self.server, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_JID, rhs: Whatsapp_V1_JID) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.server != rhs.server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Chat"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}jid\0\u{1}name\0\u{1}type\0\u{3}last_message_time\0\u{3}last_message_text\0\u{3}unread_count\0\u{3}is_muted\0\u{3}is_archived\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._jid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastMessageTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.lastMessageText) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.unreadCount) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isMuted) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._jid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._lastMessageTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.lastMessageText.isEmpty {
      try visitor.visitSingularStringField(value: self.lastMessageText, fieldNumber: 5)
    }
    if self.unreadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.unreadCount, fieldNumber: 6)
    }
    if self.isMuted != false {
      try visitor.visitSingularBoolField(value: self.isMuted, fieldNumber: 7)
    }
    if self.isArchived != false {
      try visitor.visitSingularBoolField(value: self.isArchived, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_Chat, rhs: Whatsapp_V1_Chat) -> Bool {
    if lhs._jid != rhs._jid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs._lastMessageTime != rhs._lastMessageTime {return false}
    if lhs.lastMessageText != rhs.lastMessageText {return false}
    if lhs.unreadCount != rhs.unreadCount {return false}
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.isArchived != rhs.isArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}chat_jid\0\u{3}sender_jid\0\u{1}type\0\u{1}text\0\u{1}timestamp\0\u{3}is_from_me\0\u{3}is_read\0\u{3}media_url\0\u{3}media_mime_type\0\u{3}media_filename\0\u{3}media_size\0\u{3}media_thumbnail\0\u{3}quoted_message_id\0\u{1}reaction\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _chatJid: Whatsapp_V1_JID? = nil
    var _senderJid: Whatsapp_V1_JID? = nil
    var _type: Whatsapp_V1_MessageType = .unspecified
    var _text: String = String()
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isFromMe: Bool = false
    var _isRead: Bool = false
    var _mediaURL: String = String()
    var _mediaMimeType: String = String()
    var _mediaFilename: String = String()
    var _mediaSize: UInt64 = 0
    var _mediaThumbnail: Data = Data()
    var _quotedMessageID: String = String()
    var _reaction: Whatsapp_V1_Reaction? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _chatJid = source._chatJid
      _senderJid = source._senderJid
      _type = source._type
      _text = source._text
      _timestamp = source._timestamp
      _isFromMe = source._isFromMe
      _isRead = source._isRead
      _mediaURL = source._mediaURL
      _mediaMimeType = source._mediaMimeType
      _mediaFilename = source._mediaFilename
      _mediaSize = source._mediaSize
      _mediaThumbnail = source._mediaThumbnail
      _quotedMessageID = source._quotedMessageID
      _reaction = source._reaction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._chatJid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._senderJid) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isFromMe) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._isRead) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._mediaURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._mediaMimeType) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._mediaFilename) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._mediaSize) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._mediaThumbnail) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._quotedMessageID) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._reaction) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._chatJid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._senderJid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 5)
      }
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._isFromMe != false {
        try visitor.visitSingularBoolField(value: _storage._isFromMe, fieldNumber: 7)
      }
      if _storage._isRead != false {
        try visitor.visitSingularBoolField(value: _storage._isRead, fieldNumber: 8)
      }
      if !_storage._mediaURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mediaURL, fieldNumber: 9)
      }
      if !_storage._mediaMimeType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mediaMimeType, fieldNumber: 10)
      }
      if !_storage._mediaFilename.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mediaFilename, fieldNumber: 11)
      }
      if _storage._mediaSize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._mediaSize, fieldNumber: 12)
      }
      if !_storage._mediaThumbnail.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._mediaThumbnail, fieldNumber: 13)
      }
      if !_storage._quotedMessageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._quotedMessageID, fieldNumber: 14)
      }
      try { if let v = _storage._reaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_Message, rhs: Whatsapp_V1_Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._chatJid != rhs_storage._chatJid {return false}
        if _storage._senderJid != rhs_storage._senderJid {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._isFromMe != rhs_storage._isFromMe {return false}
        if _storage._isRead != rhs_storage._isRead {return false}
        if _storage._mediaURL != rhs_storage._mediaURL {return false}
        if _storage._mediaMimeType != rhs_storage._mediaMimeType {return false}
        if _storage._mediaFilename != rhs_storage._mediaFilename {return false}
        if _storage._mediaSize != rhs_storage._mediaSize {return false}
        if _storage._mediaThumbnail != rhs_storage._mediaThumbnail {return false}
        if _storage._quotedMessageID != rhs_storage._quotedMessageID {return false}
        if _storage._reaction != rhs_storage._reaction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reaction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_message_id\0\u{1}emoji\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetMessageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetMessageID, fieldNumber: 1)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_Reaction, rhs: Whatsapp_V1_Reaction) -> Bool {
    if lhs.targetMessageID != rhs.targetMessageID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_ConnectRequest, rhs: Whatsapp_V1_ConnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_ConnectResponse, rhs: Whatsapp_V1_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_DisconnectRequest, rhs: Whatsapp_V1_DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_DisconnectResponse, rhs: Whatsapp_V1_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_LogoutRequest, rhs: Whatsapp_V1_LogoutRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_LogoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_LogoutResponse, rhs: Whatsapp_V1_LogoutResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetConnectionStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectionStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetConnectionStatusRequest, rhs: Whatsapp_V1_GetConnectionStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetConnectionStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectionStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{3}is_logged_in\0\u{3}user_jid\0\u{3}push_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isLoggedIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._userJid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pushName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.isLoggedIn != false {
      try visitor.visitSingularBoolField(value: self.isLoggedIn, fieldNumber: 2)
    }
    try { if let v = self._userJid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.pushName.isEmpty {
      try visitor.visitSingularStringField(value: self.pushName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetConnectionStatusResponse, rhs: Whatsapp_V1_GetConnectionStatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.isLoggedIn != rhs.isLoggedIn {return false}
    if lhs._userJid != rhs._userJid {return false}
    if lhs.pushName != rhs.pushName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetPairingQRRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPairingQRRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetPairingQRRequest, rhs: Whatsapp_V1_GetPairingQRRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_PairingQREvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairingQREvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}qr_code\0\u{1}timeout\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .qrCode(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .timeout(v)
        }
      }()
      case 3: try {
        var v: Whatsapp_V1_PairingSuccess?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .success(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .qrCode?: try {
      guard case .qrCode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .timeout?: try {
      guard case .timeout(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_PairingQREvent, rhs: Whatsapp_V1_PairingQREvent) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_PairingSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairingSuccess"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_jid\0\u{3}push_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userJid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pushName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userJid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pushName.isEmpty {
      try visitor.visitSingularStringField(value: self.pushName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_PairingSuccess, rhs: Whatsapp_V1_PairingSuccess) -> Bool {
    if lhs._userJid != rhs._userJid {return false}
    if lhs.pushName != rhs.pushName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_PairWithCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairWithCodeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}phone_number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phoneNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_PairWithCodeRequest, rhs: Whatsapp_V1_PairWithCodeRequest) -> Bool {
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_PairWithCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairWithCodeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pairing_code\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairingCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairingCode.isEmpty {
      try visitor.visitSingularStringField(value: self.pairingCode, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_PairWithCodeResponse, rhs: Whatsapp_V1_PairWithCodeResponse) -> Bool {
    if lhs.pairingCode != rhs.pairingCode {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetChatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}limit\0\u{1}offset\0\u{3}include_archived\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeArchived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.includeArchived != false {
      try visitor.visitSingularBoolField(value: self.includeArchived, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetChatsRequest, rhs: Whatsapp_V1_GetChatsRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.includeArchived != rhs.includeArchived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetChatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}chats\0\u{3}total_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetChatsResponse, rhs: Whatsapp_V1_GetChatsResponse) -> Bool {
    if lhs.chats != rhs.chats {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetChatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}jid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._jid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._jid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetChatRequest, rhs: Whatsapp_V1_GetChatRequest) -> Bool {
    if lhs._jid != rhs._jid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetChatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}chat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetChatResponse, rhs: Whatsapp_V1_GetChatResponse) -> Bool {
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chat_jid\0\u{1}limit\0\u{3}before_message_id\0\u{3}after_message_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatJid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.beforeMessageID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.afterMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatJid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.beforeMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.beforeMessageID, fieldNumber: 3)
    }
    if !self.afterMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.afterMessageID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetMessagesRequest, rhs: Whatsapp_V1_GetMessagesRequest) -> Bool {
    if lhs._chatJid != rhs._chatJid {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.beforeMessageID != rhs.beforeMessageID {return false}
    if lhs.afterMessageID != rhs.afterMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_GetMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMessagesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messages\0\u{3}has_more\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_GetMessagesResponse, rhs: Whatsapp_V1_GetMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chat_jid\0\u{1}text\0\u{3}quoted_message_id\0\u{3}media_data\0\u{3}media_mime_type\0\u{3}media_filename\0\u{1}type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatJid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.quotedMessageID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.mediaData) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.mediaMimeType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.mediaFilename) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatJid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.quotedMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.quotedMessageID, fieldNumber: 3)
    }
    if !self.mediaData.isEmpty {
      try visitor.visitSingularBytesField(value: self.mediaData, fieldNumber: 4)
    }
    if !self.mediaMimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaMimeType, fieldNumber: 5)
    }
    if !self.mediaFilename.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaFilename, fieldNumber: 6)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_SendMessageRequest, rhs: Whatsapp_V1_SendMessageRequest) -> Bool {
    if lhs._chatJid != rhs._chatJid {return false}
    if lhs.text != rhs.text {return false}
    if lhs.quotedMessageID != rhs.quotedMessageID {return false}
    if lhs.mediaData != rhs.mediaData {return false}
    if lhs.mediaMimeType != rhs.mediaMimeType {return false}
    if lhs.mediaFilename != rhs.mediaFilename {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_SendMessageResponse, rhs: Whatsapp_V1_SendMessageResponse) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_SendReactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendReactionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chat_jid\0\u{3}message_id\0\u{1}emoji\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatJid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatJid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_SendReactionRequest, rhs: Whatsapp_V1_SendReactionRequest) -> Bool {
    if lhs._chatJid != rhs._chatJid {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_SendReactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendReactionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_SendReactionResponse, rhs: Whatsapp_V1_SendReactionResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_MarkAsReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarkAsReadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}chat_jid\0\u{3}message_ids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatJid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.messageIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatJid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.messageIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messageIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_MarkAsReadRequest, rhs: Whatsapp_V1_MarkAsReadRequest) -> Bool {
    if lhs._chatJid != rhs._chatJid {return false}
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_MarkAsReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarkAsReadResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_MarkAsReadResponse, rhs: Whatsapp_V1_MarkAsReadResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_StreamEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamEventsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_types\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.eventTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.eventTypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_StreamEventsRequest, rhs: Whatsapp_V1_StreamEventsRequest) -> Bool {
    if lhs.eventTypes != rhs.eventTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_WhatsAppEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhatsAppEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}timestamp\0\u{3}message_event\0\u{3}chat_event\0\u{3}connection_event\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try {
        var v: Whatsapp_V1_MessageEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .messageEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .messageEvent(v)
        }
      }()
      case 4: try {
        var v: Whatsapp_V1_ChatEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .chatEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .chatEvent(v)
        }
      }()
      case 5: try {
        var v: Whatsapp_V1_ConnectionEvent?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .connectionEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .connectionEvent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.payload {
    case .messageEvent?: try {
      guard case .messageEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .chatEvent?: try {
      guard case .chatEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .connectionEvent?: try {
      guard case .connectionEvent(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_WhatsAppEvent, rhs: Whatsapp_V1_WhatsAppEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_MessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_MessageEvent, rhs: Whatsapp_V1_MessageEvent) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_ChatEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}chat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_ChatEvent, rhs: Whatsapp_V1_ChatEvent) -> Bool {
    if lhs._chat != rhs._chat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Whatsapp_V1_ConnectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Whatsapp_V1_ConnectionEvent, rhs: Whatsapp_V1_ConnectionEvent) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
